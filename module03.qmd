---
title: "Processes and OS Management"
author: "Brad Smith"
format: html
editor: visual
---

# Module 3: Understanding Processes and OS Management

------------------------------------------------------------------------

## ðŸ§­ Module 3 Overview

\*\*Narrative

This module introduces one of the foundational concepts in operating systems: the process. We explore how processes are created, managed, and isolated by the operating system. This is particularly important in embedded systems, where stability and predictability are critical.

**ðŸŽž Slide**

**Module 3 Overview** - What is a process? - The OS role in process creation and management - Process memory space and protection - Process state and the Program Counter - Multiple instances of a process - Embedded relevance

![](images/module03/Module03_slidedeck/Module03_slidedeck.002.png)

**ðŸ”„ Segue**

Letâ€™s begin by understanding what a process really is â€” and why it's more than just a program.

------------------------------------------------------------------------

## What is a Process?

**ðŸ§­ Narrative**

A **process** is an instance of a program in execution. While a program is a passive set of instructions (e.g., a compiled `.exe` or binary), a process is active. It includes: - A unique **Process ID (PID)** - Its own **memory space** - A **Program Counter (PC)** pointing to the next instruction - Associated resources like open files, scheduling information, and CPU registers

**ðŸŽž Slide - What is a Process?**

**What is a Process?** - A running instance of a program - Unique PID, memory space, PC - Managed and isolated by the OS ![](images/module03/Module03_slidedeck/Module03_slidedeck.003.png) **ðŸ”„ Segue**

Letâ€™s now take a closer look at what the operating system actually does when you launch a process.

------------------------------------------------------------------------

## The Role of the Operating System

**ðŸ§­ Narrative**

When you run a program, the OS: 1. **Loads the executable** into memory 2. **Allocates a private memory space** 3. **Initializes the stack and heap** 4. **Sets the PC** to the entry point 5. **Schedules the process** to run via the CPU

This allows the system to safely manage multiple processes running concurrently without interference.

**ðŸŽž Slide - The Role of the Operating System**

![](images/module03/Module03_slidedeck/Module03_slidedeck.004.png)

**The Role of the Operating System** - Load and set up the program - Assign memory - Track with PCB and PC - Schedule to run

**ðŸ”„ Segue**

To make this real, letâ€™s look at a simple C program that demonstrates how a new process is created.

------------------------------------------------------------------------

## Simple C program fork()

**ðŸ§­ Narrative**

This simple C program uses `fork()` to duplicate the current process:

**ðŸŽž Slide - Simple C program fork()**
![](images/module03/Module03_slidedeck/Module03_slidedeck.005.png)
``` c
#include <stdio.h>
#include <unistd.h>
int main() {
    printf("Parent PID: %d\n", getpid());
    fork();
    printf("Hello from PID: %d\n", getpid());
    return 0;
}
```

This program shows that each process, while sharing code, executes independently.

**ðŸ”„ Segue**

But how does each process keep track of where it is and what memory itâ€™s using? Letâ€™s look at memory layout.

------------------------------------------------------------------------

## Process Memory Layout

**ðŸ§­ Narrative**

Each process has a well-defined layout: - **Text segment:** Executable code - **Data segment:** Initialized global/static variables - **BSS:** Uninitialized globals/statics - **Heap:** Grows up with `malloc()` - **Stack:** Grows down with function calls

In embedded systems, managing this layout carefully is crucial to avoid overflow or unpredictable behavior.

**ðŸŽž Slide - Process Memory Layout**
![](images/module03/Module03_slidedeck/Module03_slidedeck.006.png)
**Process Memory Layout** - Text, Data, BSS, Heap, Stack - Visually organized top-to-bottom

**ðŸ”„ Segue**

Weâ€™ve said each process is isolated. How is that enforced? Letâ€™s look at memory protection.

------------------------------------------------------------------------

## Memory Protection

**ðŸ§­ Narrative**

**Memory protection** ensures stability: - One process cannot access anotherâ€™s memory - Uses MMU (Memory Management Unit) - Violations cause segmentation faults

This is critical in embedded systems where shared resources could lead to system crashes.

**ðŸŽž Slide - Memory Protection**
![](images/module03/Module03_slidedeck/Module03_slidedeck.007.png)
**Memory Protection** - Prevents interference - MMU-enforced - Segfaults signal boundary violations

**ðŸ”„ Segue**

Now that weâ€™ve covered structure and safety, letâ€™s explore how processes move through their lifecycle.

------------------------------------------------------------------------

## Process State Model

**ðŸ§­ Narrative**

A process transitions through several states: - New â†’ Ready â†’ Running â†’ Blocked â†’ Exit

The OS keeps track using a **Process Control Block (PCB)** that holds: - PID - PC - State - Memory pointers

**ðŸŽž Slide - Process State Model**
![](images/module03/Module03_slidedeck/Module03_slidedeck.008.png)
**Process State Model** - Visual state diagram - PCB components listed

**ðŸ”„ Segue**

All of this is possible because the Program Counter tells the CPU what to do next. Letâ€™s focus on that next.

------------------------------------------------------------------------

## The Program Counter (PC)

**ðŸ§­ Narrative**

The **Program Counter (PC)** tracks which instruction to execute: - Saved/restored during context switching - Enables multitasking

Think of it like a bookmark in a book â€” each process has its own.

**ðŸŽž Slide - The Program Counter (PC)**
![](images/module03/Module03_slidedeck/Module03_slidedeck.009.png)
**The Program Counter (PC)** - Tracks execution - Saved during switches - Book analogy

**ðŸ”„ Segue**

Now, letâ€™s examine how the system handles running multiple processes of the same program.

------------------------------------------------------------------------

## Multiple Instances of a Process

**ðŸ§­ Narrative**

Itâ€™s common to run multiple instances of the same program:

``` bash
$ sleep 60 &
$ sleep 60 &
$ ps aux | grep sleep
```

Each one is isolated and scheduled independently.

**ðŸŽž Slide - Multiple Instances of a Process**
![](images/module03/Module03_slidedeck/Module03_slidedeck.010.png)
**Multiple Instances of a Process** - Same binary, different state - Unique PID and memory

**ðŸ”„ Segue**

This is essential in embedded contexts where multiple services run in parallel â€” each safely managed.

------------------------------------------------------------------------

## Embedded Context

**ðŸ§­ Narrative**

In embedded systems: - Resource constraints are stricter - Real-time response is critical - Static allocation is preferred

But the concept of isolated, predictable process execution remains vital.

**ðŸŽž Slide - Embedded Context**
![](images/module03/Module03_slidedeck/Module03_slidedeck.011.png)
**Embedded Context** - Fewer processes, stricter rules - Isolation protects critical operations

**ðŸ”„ Segue**

Letâ€™s test our understanding with a short exercise.

------------------------------------------------------------------------

### Checkpoint Exercise

**ðŸ§­ Narrative**

**Checkpoint Exercise:** Write a C program that: 1. Forks two child processes 2. Prints each PID and memory address of a local variable 3. Observe how address spaces differ

**ðŸŽž Slide - Checkpoint Exercise**
![](images/module03/Module03_slidedeck/Module03_slidedeck.013.png)

**Checkpoint Exercise** - Fork + observe memory - Compare address outputs

**ðŸ”„ Segue**

Letâ€™s wrap up with key takeaways from this module.

------------------------------------------------------------------------

### Summary

**ðŸ§­ Narrative**

-   Processes are the building blocks of multitasking
-   OS handles memory and execution state
-   Each process is isolated and independently managed
-   The PC, memory layout, and state tracking are key OS responsibilities

**ðŸŽž Slide - Summary**

**Summary** - Key responsibilities of OS - Memory and execution isolation - Embedded considerations

![](images/module03/Module03_slidedeck/Module03_slidedeck.012.png)

**ðŸ”„ Segue**

Next time, weâ€™ll explore how the OS juggles processes using scheduling.

------------------------------------------------------------------------

### Coming Next

**ðŸ§­ Narrative**

Weâ€™ll cover scheduling algorithms and how the OS decides which process runs next â€” including real-time scheduling in embedded systems.

**ðŸŽž Slide - Coming Next**
![](images/module03/Module03_slidedeck/Module03_slidedeck.014.png)
**Coming Next** - Context switching - Scheduling strategies
![](images/module03/Module03_slidedeck/Module03_slidedeck.015.png)
------------------------------------------------------------------------

> This content is designed to accompany the Module03_slidedeck.qmd and prepare students for lab exercises and embedded applications.
