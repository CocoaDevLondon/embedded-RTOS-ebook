<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Linux-based Embedded System</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./module03.html" rel="next">
<link href="./lecture01.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-626149efe8f5d16e1d391ba177679bf0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./lecture02.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Linux-based Embedded System</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Embedded RTOS Course eBook</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Intro. to Embedded Systems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lecture02.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Linux-based Embedded System</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./module03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Processes and OS Management</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#slides-linux-based-embedded-system-components" id="toc-slides-linux-based-embedded-system-components" class="nav-link active" data-scroll-target="#slides-linux-based-embedded-system-components"><span class="header-section-number">3.1</span> Slides: Linux-based Embedded System Components</a></li>
  <li><a href="#slide-hardware-reference-model" id="toc-slide-hardware-reference-model" class="nav-link" data-scroll-target="#slide-hardware-reference-model"><span class="header-section-number">3.2</span> Slide: Hardware Reference Model</a></li>
  <li><a href="#slide-hardware-reference-implementations" id="toc-slide-hardware-reference-implementations" class="nav-link" data-scroll-target="#slide-hardware-reference-implementations"><span class="header-section-number">3.3</span> Slide: Hardware Reference Implementations</a></li>
  <li><a href="#slide-bootloader---key-responsibilities" id="toc-slide-bootloader---key-responsibilities" class="nav-link" data-scroll-target="#slide-bootloader---key-responsibilities"><span class="header-section-number">3.4</span> Slide: Bootloader - Key Responsibilities</a></li>
  <li><a href="#slide-understanding-the-program-counter-pc" id="toc-slide-understanding-the-program-counter-pc" class="nav-link" data-scroll-target="#slide-understanding-the-program-counter-pc"><span class="header-section-number">3.5</span> Slide: Understanding the Program Counter (PC)</a></li>
  <li><a href="#slide-processor-startup-and-the-reset-vector" id="toc-slide-processor-startup-and-the-reset-vector" class="nav-link" data-scroll-target="#slide-processor-startup-and-the-reset-vector"><span class="header-section-number">3.6</span> Slide: Processor Startup and the Reset Vector</a></li>
  <li><a href="#slide-scenario-1-typical-of-microcontrollers" id="toc-slide-scenario-1-typical-of-microcontrollers" class="nav-link" data-scroll-target="#slide-scenario-1-typical-of-microcontrollers"><span class="header-section-number">3.7</span> Slide: Scenario 1, typical of microcontrollers</a></li>
  <li><a href="#slide-scenario-2-typical-of-a-more-complex-system-on-chip-hardware" id="toc-slide-scenario-2-typical-of-a-more-complex-system-on-chip-hardware" class="nav-link" data-scroll-target="#slide-scenario-2-typical-of-a-more-complex-system-on-chip-hardware"><span class="header-section-number">3.8</span> Slide: Scenario 2, Typical of a more complex System-on-Chip hardware</a></li>
  <li><a href="#slide-bootloader-operations-initial-conditions-before-power-up" id="toc-slide-bootloader-operations-initial-conditions-before-power-up" class="nav-link" data-scroll-target="#slide-bootloader-operations-initial-conditions-before-power-up"><span class="header-section-number">3.9</span> Slide: Bootloader Operations: Initial Conditions (Before Power-up)</a></li>
  <li><a href="#slide-bootloader-operations-cpu-reset-vector-at-power-up" id="toc-slide-bootloader-operations-cpu-reset-vector-at-power-up" class="nav-link" data-scroll-target="#slide-bootloader-operations-cpu-reset-vector-at-power-up"><span class="header-section-number">3.10</span> Slide: Bootloader Operations: CPU Reset Vector at Power-up</a></li>
  <li><a href="#slide-bootloader-operations-during-bootstrap" id="toc-slide-bootloader-operations-during-bootstrap" class="nav-link" data-scroll-target="#slide-bootloader-operations-during-bootstrap"><span class="header-section-number">3.11</span> Slide: Bootloader Operations: During Bootstrap</a></li>
  <li><a href="#slide-bootloader-operations-transition-to-operating-system" id="toc-slide-bootloader-operations-transition-to-operating-system" class="nav-link" data-scroll-target="#slide-bootloader-operations-transition-to-operating-system"><span class="header-section-number">3.12</span> Slide: Bootloader Operations: Transition to Operating System</a></li>
  <li><a href="#slide-role-of-the-linux-kernel-in-embedded-systems" id="toc-slide-role-of-the-linux-kernel-in-embedded-systems" class="nav-link" data-scroll-target="#slide-role-of-the-linux-kernel-in-embedded-systems"><span class="header-section-number">3.13</span> Slide: Role of the Linux Kernel in Embedded Systems</a></li>
  <li><a href="#slide-linux-kernel-layered-operating-system-structure" id="toc-slide-linux-kernel-layered-operating-system-structure" class="nav-link" data-scroll-target="#slide-linux-kernel-layered-operating-system-structure"><span class="header-section-number">3.14</span> Slide: Linux Kernel: Layered Operating System Structure</a></li>
  <li><a href="#slide-monolithic-kernel-advantages-and-disadvantages" id="toc-slide-monolithic-kernel-advantages-and-disadvantages" class="nav-link" data-scroll-target="#slide-monolithic-kernel-advantages-and-disadvantages"><span class="header-section-number">3.15</span> Slide: Monolithic Kernel: Advantages and Disadvantages</a></li>
  <li><a href="#slide-device-tree-flexible-hardware-descriptions-for-the-kernel" id="toc-slide-device-tree-flexible-hardware-descriptions-for-the-kernel" class="nav-link" data-scroll-target="#slide-device-tree-flexible-hardware-descriptions-for-the-kernel"><span class="header-section-number">3.16</span> Slide: Device Tree: Flexible Hardware Descriptions for the Kernel</a></li>
  <li><a href="#slide-system-programs-tools-built-on-kernel-services" id="toc-slide-system-programs-tools-built-on-kernel-services" class="nav-link" data-scroll-target="#slide-system-programs-tools-built-on-kernel-services"><span class="header-section-number">3.17</span> Slide: System Programs: Tools Built on Kernel Services</a></li>
  <li><a href="#slide-application-layer" id="toc-slide-application-layer" class="nav-link" data-scroll-target="#slide-application-layer"><span class="header-section-number">3.18</span> Slide: Application Layer</a></li>
  <li><a href="#slide-root-filesystem-the-foundation-of-user-space" id="toc-slide-root-filesystem-the-foundation-of-user-space" class="nav-link" data-scroll-target="#slide-root-filesystem-the-foundation-of-user-space"><span class="header-section-number">3.19</span> Slide: Root Filesystem: The Foundation of User Space</a></li>
  <li><a href="#slide-root-file-system-illustrated" id="toc-slide-root-file-system-illustrated" class="nav-link" data-scroll-target="#slide-root-file-system-illustrated"><span class="header-section-number">3.20</span> Slide: Root File System Illustrated</a></li>
  <li><a href="#review-for-module-02" id="toc-review-for-module-02" class="nav-link" data-scroll-target="#review-for-module-02"><span class="header-section-number">3.21</span> Review for Module 02</a></li>
  <li><a href="#answer-key-for-module-02-review-questions" id="toc-answer-key-for-module-02-review-questions" class="nav-link" data-scroll-target="#answer-key-for-module-02-review-questions"><span class="header-section-number">3.22</span> Answer Key for Module 02 Review Questions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Linux-based Embedded System</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="slides-linux-based-embedded-system-components" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="slides-linux-based-embedded-system-components"><span class="header-section-number">3.1</span> Slides: Linux-based Embedded System Components</h2>
<ul>
<li><p>Narrative: “As we saw previously, embedded Linux systems rely on a structured set of core components. The Bootloader ensures hardware readiness at startup, preparing the system for the Linux Kernel, which manages critical resources. The kernel leverages a Device Tree for flexible hardware configuration without constant recompilation. System programs make interactions user-friendly, providing an accessible interface to system capabilities. Your actual application software defines the ultimate purpose of your embedded device, such as controlling industrial machinery or managing multimedia content. Finally, all this software and configuration data reside within a carefully structured Root Filesystem, ensuring that the system remains organized and operational.”</p></li>
<li><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.005.png" class="img-fluid figure-img"></p>
<figcaption>Components 1 of 2</figcaption>
</figure>
</div>
<ul>
<li><p>Bootloader: At power-up, the bootloader prepares the hardware and facilitates the transition to the operating system. It initializes system resources and provides essential startup information to the Linux kernel.</p></li>
<li><p>Device Tree: This is a data structure that describes hardware components, allowing the kernel to configure and manage device drivers without needing hardware definitions to be hard-coded. The device tree is crucial for flexibility, enabling easier updates to hardware configurations.</p></li>
<li><p>Linux Kernel: The kernel is the heart of the embedded system, managing resources such as CPU, memory, processes, and I/O interactions. It provides a robust and versatile foundation, supporting various hardware architectures and extensive functionalities.</p></li>
</ul></li>
<li><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.006.png" class="img-fluid figure-img"></p>
<figcaption>Components 2 of 2</figcaption>
</figure>
</div>
<ul>
<li><p>System Programs: These include user-friendly utilities and services that facilitate interaction with the system hardware and kernel, simplifying development and maintenance.</p></li>
<li><p>Application: This refers to the user-specific software that delivers the embedded system’s core functionality, tailored to the product’s end-use.</p></li>
<li><p>Root Filesystem: The root filesystem stores the Linux kernel configuration, essential system programs, application software, and user-space utilities. It defines the operational environment and can be configured for persistent storage or temporary, RAM-based storage depending on system requirements.” Transition Statement:“Understanding these foundational components is vital for comprehending how Linux is structured within an embedded context. As we move forward, we’ll examine each component individually to appreciate their roles and interactions in greater detail.”</p></li>
</ul></li>
<li><p>Suggested Resources:</p>
<ul>
<li>“Embedded Linux Primer” by Christopher Hallinan: ◦ Chapters detailing bootloader roles, device trees, and kernel fundamentals.</li>
<li>Linux Kernel Documentation: ◦ Comprehensive explanations of the kernel architecture and subsystems (https:// www.kernel.org/doc/html/latest/).</li>
<li>Device Tree Documentation: ◦ In-depth usage guidelines for DTS and DTB formats (https://devicetree.org/).</li>
<li>Bootloader examples: ◦ Practical examples using U-Boot for embedded Linux devices (https:// www.denx.de/wiki/U-Boot).</li>
<li>Embedded Linux Introduction
<ul>
<li>https://community.intel.com/t5/Blogs/Products-and-Solutions/Software/Loading-and-Starting-a- Linux-Kernel-in-Five-Different-Ways/post/1571900</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="slide-hardware-reference-model" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="slide-hardware-reference-model"><span class="header-section-number">3.2</span> Slide: Hardware Reference Model</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.007.png" class="img-fluid figure-img"></p>
<figcaption>Embedded System Hardware Reference</figcaption>
</figure>
</div>
<p>Narrative: “Embedded systems consist of hardware components carefully selected to meet specific performance and functionality goals. The CPU is the central component that executes instructions, controlling system operations. RAM memory provides fast, volatile storage for running software, crucial during system operation but cleared once power is lost. I/O peripherals allow the embedded system to interact with users and external environments through inputs (like sensors or buttons) and outputs (such as actuators or screens). The Boot Flash memory stores initial boot software that prepares hardware upon startup. Finally, the Mass Storage Flash holds the main operating system, applications, and any data requiring persistent storage.”</p>
<ul>
<li><p>Helpful Resources for Further Development:</p>
<ul>
<li><p>“Embedded Systems with ARM Cortex-M Microcontrollers in Assembly Language and C” by Yifeng Zhu (clear diagrams and foundational explanations of hardware components).</p></li>
<li><p>“Designing Embedded Hardware” by John Catsoulis (useful diagrams and practical descriptions of hardware components).</p></li>
</ul></li>
</ul>
</section>
<section id="slide-hardware-reference-implementations" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="slide-hardware-reference-implementations"><span class="header-section-number">3.3</span> Slide: Hardware Reference Implementations</h2>
<ul>
<li><p>Narrative:</p></li>
<li><p>“In embedded systems, hardware implementations generally fall into two main categories:</p>
<ul>
<li><p>Microcontroller-based implementations (MCU) typically integrate most system components— such as the CPU, small amounts of RAM and Flash memory, and basic I/O peripherals— within a single chip. These systems oﬀer simplicity, cost-eﬀectiveness, and lower power consumption, making them suitable for simpler embedded applications like automotive sensors, home appliances, and simple control systems.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.008.png" class="img-fluid figure-img"></p>
<figcaption>Embedded System Hardware Reference</figcaption>
</figure>
</div></li>
<li><p>System-on-Chip (SoC) implementations, on the other hand, integrate a broader range of advanced system components—including CPU cores, memory controllers, graphical processors (GPU), digital signal processors (DSP), advanced I/O peripherals, and even networking interfaces—onto a single silicon chip. This high degree of integration significantly reduces complexity, lowers power usage, and improves performance. SoCs are ideal for more complex embedded applications demanding robust processing, multimedia capabilities, extensive connectivity, or specialized tasks—examples include smartphones, tablets, smart TVs, automotive infotainment systems, and network routers. Understanding these distinctions helps engineers select appropriate hardware platforms based on application requirements, performance goals, cost constraints, and power budgets.” <img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.009.png" class="img-fluid" alt="Embedded System Hardware Reference SOC"></p></li>
</ul></li>
</ul>
</section>
<section id="slide-bootloader---key-responsibilities" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="slide-bootloader---key-responsibilities"><span class="header-section-number">3.4</span> Slide: Bootloader - Key Responsibilities</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.011.png" class="img-fluid figure-img"></p>
<figcaption>Bootloader - Key responsibilities</figcaption>
</figure>
</div>
<ul>
<li>Narrative: “At startup, a system’s processor cannot immediately run applications or even the operating system directly. Instead, it relies on a special software called the bootloader to initialize the hardware, prepare memory, and set up basic processor configurations. Specifically, the bootloader locates the kernel software, ensures it’s properly loaded into memory, and creates an environment suitable for the operating system to take control. In essence, the bootloader bridges the gap between hardware startup and operating system execution.”<br>
</li>
<li>Supporting Resources for Further Exploration:
<ul>
<li>U-Boot documentation (practical bootloader reference): U-Boot Project</li>
<li>Bootlin Embedded Linux Training (Bootloader section): Bootloader Training PDF</li>
</ul></li>
<li></li>
</ul>
</section>
<section id="slide-understanding-the-program-counter-pc" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="slide-understanding-the-program-counter-pc"><span class="header-section-number">3.5</span> Slide: Understanding the Program Counter (PC)</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.012.png" class="img-fluid figure-img"></p>
<figcaption>Program Counter</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong></p>
<ul>
<li>“Before diving deeper into system startup, let’s clarify the role of a critical CPU register called the Program Counter, or PC. The PC is essentially the CPU’s internal pointer, always indicating the memory address of the next instruction to execute.</li>
<li>With each executed instruction, the CPU automatically updates the PC to point sequentially to the next instruction. At power-up or after a reset, the PC doesn’t point randomly; instead, it’s set to a specific, known address— called the Reset Vector.</li>
<li>Understanding the role of the Program Counter is essential because it directly influences how software execution flows within a CPU.”</li>
</ul>
</section>
<section id="slide-processor-startup-and-the-reset-vector" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="slide-processor-startup-and-the-reset-vector"><span class="header-section-number">3.6</span> Slide: Processor Startup and the Reset Vector</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.013.png" class="img-fluid figure-img"></p>
<figcaption>Reset Vector</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong></p>
<ul>
<li><p>“Now that we understand the Program Counter, we can clearly see why the Reset Vector is essential.</p></li>
<li><p>At startup, the CPU automatically sets the PC to this Reset Vector— directing it to execute a small piece of initial software, typically part of the bootloader.</p></li>
<li><p>This startup code provides critical configuration details, such as where the main software is located, how to access it, and how to configure essential memory structures like the stack.</p></li>
<li><p>Although the specifics may diﬀer between systems, this foundational sequence is consistent across virtually all embedded processors.”</p></li>
<li><p>Additional Resources for Narrative Development:</p>
<ul>
<li><p>Computer Organization and Design (RISC-V Edition) by Patterson and Hennessy, provides clear foundational explanations about program counters and CPU instruction execution flow.</p></li>
<li><p>Embedded System Design by Frank Vahid and Tony Givargis, detailing startup sequences and reset vectors clearly.</p></li>
</ul></li>
</ul>
</section>
<section id="slide-scenario-1-typical-of-microcontrollers" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="slide-scenario-1-typical-of-microcontrollers"><span class="header-section-number">3.7</span> Slide: Scenario 1, typical of microcontrollers</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.014.png" class="img-fluid figure-img"></p>
<figcaption>Microcontroller reset</figcaption>
</figure>
</div>
<p><strong>Narrative</strong>:</p>
<ul>
<li><p>“In embedded Linux systems, the exact startup scenario varies depending on hardware architecture.</p></li>
<li><p>In a microcontroller (MCU) system, all necessary software—including bootloader, operating system, and applications—typically resides in internal flash memory.</p></li>
<li><p>The software executes directly from this embedded storage, simplifying hardware design.</p></li>
<li><p>Embedded RAM serves only as temporary storage for active data, stack, and heap.”</p></li>
</ul>
</section>
<section id="slide-scenario-2-typical-of-a-more-complex-system-on-chip-hardware" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="slide-scenario-2-typical-of-a-more-complex-system-on-chip-hardware"><span class="header-section-number">3.8</span> Slide: Scenario 2, Typical of a more complex System-on-Chip hardware</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.015.png" class="img-fluid figure-img"></p>
<figcaption>SoC reset</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong></p>
<ul>
<li>Conversely, System-on-Chip (SoC) systems often separate boot flash memory, which holds only the initial bootloader and reset vector, from a larger, external mass storage containing the full operating system, applications, and filesystem.</li>
<li>At startup, the bootloader loads the operating system and applications into external RAM, where they execute.</li>
<li>This scenario allows greater flexibility and scalability for complex embedded applications, but involves more intricate hardware design.”</li>
</ul>
<p><strong>Useful Resources for Further Reference:</strong></p>
<ul>
<li><p>Bootlin Embedded Linux Training (Architecture): Bootlin Architecture Slides</p></li>
<li><p>“Embedded Linux Primer” by Christopher Hallinan: Excellent details on these boot scenarios and hardware diﬀerences.</p></li>
</ul>
</section>
<section id="slide-bootloader-operations-initial-conditions-before-power-up" class="level2" data-number="3.9">
<h2 data-number="3.9" class="anchored" data-anchor-id="slide-bootloader-operations-initial-conditions-before-power-up"><span class="header-section-number">3.9</span> Slide: Bootloader Operations: Initial Conditions (Before Power-up)</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.016.png" class="img-fluid figure-img"></p>
<figcaption>SoC reset</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong> - “Before the embedded device powers up, its bootloader and reset vector are stored in boot flash memory, and the operating system and applications reside in mass storage flash. - RAM memory, being volatile, is initially empty and uninitialized.”</p>
</section>
<section id="slide-bootloader-operations-cpu-reset-vector-at-power-up" class="level2" data-number="3.10">
<h2 data-number="3.10" class="anchored" data-anchor-id="slide-bootloader-operations-cpu-reset-vector-at-power-up"><span class="header-section-number">3.10</span> Slide: Bootloader Operations: CPU Reset Vector at Power-up</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.017.png" class="img-fluid figure-img"></p>
<figcaption>SoC reset</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong></p>
<ul>
<li>“At power-up, the CPU loads the reset vector into its Program Counter, directing it to execute the bootloader’s first instruction. This marks the start of the bootstrap process.”</li>
</ul>
</section>
<section id="slide-bootloader-operations-during-bootstrap" class="level2" data-number="3.11">
<h2 data-number="3.11" class="anchored" data-anchor-id="slide-bootloader-operations-during-bootstrap"><span class="header-section-number">3.11</span> Slide: Bootloader Operations: During Bootstrap</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.018.png" class="img-fluid figure-img"></p>
<figcaption>bootstrap</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong> - “During bootstrap, the bootloader configures essential hardware resources, initializes RAM, and transfers operating system and other software components from persistent storage into RAM, preparing them for execution.”</p>
</section>
<section id="slide-bootloader-operations-transition-to-operating-system" class="level2" data-number="3.12">
<h2 data-number="3.12" class="anchored" data-anchor-id="slide-bootloader-operations-transition-to-operating-system"><span class="header-section-number">3.12</span> Slide: Bootloader Operations: Transition to Operating System</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.019.png" class="img-fluid figure-img"></p>
<figcaption>Transition to OS execution</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong></p>
<p>“At the end of the bootstrap process, the bootloader transfers control to the operating system, eﬀectively stepping aside as the OS takes responsibility for managing the system’s resources and starting user applications.”</p>
<p><strong>Supporting Resources for Further Narrative Development:</strong></p>
<p>- Bootlin Training: Embedded Linux Boot Sequence (Bootlin Slides <a href="https://bootlin.com/doc/training/sessions/online.embedded-linux.apr2024/embedded-linux-slides.pdf" title="Bootlin Slides">Bootlin Slides</a>)</p>
<p>- Embedded Linux Primer by Christopher Hallinan: Detailed yet clear explanations of each step in the bootloader sequence.</p>
</section>
<section id="slide-role-of-the-linux-kernel-in-embedded-systems" class="level2" data-number="3.13">
<h2 data-number="3.13" class="anchored" data-anchor-id="slide-role-of-the-linux-kernel-in-embedded-systems"><span class="header-section-number">3.13</span> Slide: Role of the Linux Kernel in Embedded Systems</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.021.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative:</strong></p>
<ul>
<li><p>“The Linux kernel is the core software component within embedded Linux systems, responsible for managing hardware resources efficiently and reliably.</p></li>
<li><p>It ensures that multiple applications or processes can run smoothly by handling process creation, scheduling, and management. It also manages memory allocation and protection, ensuring programs don’t interfere with each other or the system itself.</p></li>
<li><p>Device drivers within the kernel handle input and output with external devices—such as sensors or actuators.</p></li>
<li><p>Moreover, the kernel provides critical support for organizing data through file systems, facilitates communication across networks, and allows processes to share information through inter-process communication.</p></li>
<li><p>In essence, the kernel acts as the critical link between software applications and hardware.”</p></li>
</ul>
<p><strong>Supporting Resources for Further Narrative Development:</strong></p>
<ul>
<li>“Linux Kernel Development” by Robert Love: Clear explanations and diagrams about kernel responsibilities.</li>
<li>Kernel documentation (<a href="https://www.kernel.org/doc/html/latest/" title="Kernel Documentation">kernel.org</a>): Kernel Documentation (Official resource with detailed explanations).</li>
</ul>
</section>
<section id="slide-linux-kernel-layered-operating-system-structure" class="level2" data-number="3.14">
<h2 data-number="3.14" class="anchored" data-anchor-id="slide-linux-kernel-layered-operating-system-structure"><span class="header-section-number">3.14</span> Slide: Linux Kernel: Layered Operating System Structure</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.022.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative</strong></p>
<ul>
<li><p>“In Linux, the operating system is designed using a two-layer approach: kernel space and user space. Think of kernel space as the area of the operating system that directly manages your hardware—controlling memory, running processes, and handling all hardware interactions. User space, on the other hand, is where your applications and programs run. To maintain system stability, these applications don’t directly access hardware; instead, they ask the kernel to perform tasks on their behalf.</p></li>
<li><p>The Linux kernel is described as a monolithic kernel, meaning it bundles all core functions into a single, large executable. This design makes the kernel very efficient but also means that a serious error in one kernel function can potentially impact the entire system.</p></li>
<li><p>To improve flexibility and reduce this risk, Linux supports loadable kernel modules, small pieces of software you can add or remove while the system is running. These modules commonly provide new features such as additional device drivers, network support, or file system enhancements.”</p></li>
<li><p>Resource: <a href="https://www.eeweb.com/embedded-linux-design-kernel-analysis/">embedded-linux-design-kernel-analysis</a></p></li>
</ul>
</section>
<section id="slide-monolithic-kernel-advantages-and-disadvantages" class="level2" data-number="3.15">
<h2 data-number="3.15" class="anchored" data-anchor-id="slide-monolithic-kernel-advantages-and-disadvantages"><span class="header-section-number">3.15</span> Slide: Monolithic Kernel: Advantages and Disadvantages</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.023.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative</strong></p>
<ul>
<li><p>“The monolithic design of the Linux kernel offers significant advantages, primarily through its strong separation between the user applications and kernel-level processes. Because of this separation, errors in user applications typically do not affect the stability or security of the kernel itself—ensuring system reliability.</p></li>
<li><p>However, the same tightly integrated nature also introduces a notable disadvantage: a bug or error within any part of the kernel, such as a newly installed device driver or network component, can potentially destabilize or crash the entire operating system. This risk necessitates meticulous design, rigorous testing, and careful management of kernel-level software changes.”</p></li>
</ul>
<p><strong>Additional Resources for Further Reading:</strong></p>
<ul>
<li><p>“Understanding the Linux Kernel” by Daniel P. Bovet and Marco Cesati for in-depth exploration of monolithic kernels.</p></li>
<li><p>“Linux Kernel Development” by Robert Love (excellent for clear explanations of kernel architecture implications).</p></li>
</ul>
</section>
<section id="slide-device-tree-flexible-hardware-descriptions-for-the-kernel" class="level2" data-number="3.16">
<h2 data-number="3.16" class="anchored" data-anchor-id="slide-device-tree-flexible-hardware-descriptions-for-the-kernel"><span class="header-section-number">3.16</span> Slide: Device Tree: Flexible Hardware Descriptions for the Kernel</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.025.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative</strong></p>
<p>“The Linux kernel needs to understand the system’s hardware to load the correct drivers and manage resources. While one approach would be to hardcode this hardware information directly into the kernel source code, that method becomes cumbersome and time-consuming if the hardware changes, as it requires kernel recompilation.</p>
<p>The more flexible and modern approach is to use a device tree. This involves describing the hardware in a Device Tree Source (DTS) file, which is then compiled into a binary Device Tree Blob (DTB). The bootloader passes this DTB to the kernel at startup, allowing the kernel to dynamically understand the hardware setup. This method makes it easy to update or support new hardware without rebuilding the kernel — simply modify the DTS and recompile.” <img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.026.png" class="img-fluid" alt="kernel"></p>
<p><strong>Helpful Resource:</strong></p>
<p>• Linux Kernel Device Tree documentation: <a href="https://www.kernel.org/doc/html/latest/devicetree/usage-model.html" class="uri">https://www.kernel.org/doc/html/latest/devicetree/usage-model.html</a></p>
<p><a href="https://medium.com/@boutnaru/the-linux-concept-journey-devicetree-58b36eee5387">The Linux Concept Journey — DeviceTree</a></p>
</section>
<section id="slide-system-programs-tools-built-on-kernel-services" class="level2" data-number="3.17">
<h2 data-number="3.17" class="anchored" data-anchor-id="slide-system-programs-tools-built-on-kernel-services"><span class="header-section-number">3.17</span> Slide: System Programs: Tools Built on Kernel Services</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.028.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative</strong></p>
<p>“System programs are the essential tools that sit between user applications and the kernel, providing convenient interfaces for both development and system management. These programs rely on kernel services but make interacting with them much more user-friendly.</p>
<p>For instance, system programs include utilities that show status information about the system, such as top or uptime. They also offer file modification tools, like text editors and file manipulation commands. Developers benefit from programming support tools like compilers and language interpreters.</p>
<p>Furthermore, system programs help with program loading and execution, using tools like shells (bash) or service managers (systemd). For networking and communication, utilities like ping and ssh allow interaction with remote systems. Finally, many lightweight applications, like curl or tools included in BusyBox, help perform everyday tasks in embedded systems.”</p>
<p><strong>Resources</strong></p>
<p>Resource for Reference:</p>
<p>•<a href="https://www.busybox.net/about.html">BusyBox website</a> (a great real-world example of system programs in embedded Linux):</p>
<p>• “Linux Command Line and Shell Scripting Bible” by Richard Blum — can help build student familiarity with system programs.</p>
</section>
<section id="slide-application-layer" class="level2" data-number="3.18">
<h2 data-number="3.18" class="anchored" data-anchor-id="slide-application-layer"><span class="header-section-number">3.18</span> Slide: Application Layer</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.030.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative</strong></p>
<p>“At the top of the software stack sits the application layer, which is where the embedded system’s purpose comes to life. Whether the device is a home router, a smart thermostat, or a piece of lab equipment, the application software is what users interact with. It relies on system programs and kernel services to access hardware and perform tasks.</p>
<p>For example, in a Network Attached Storage (NAS) device, the application manages file sharing and disk operations. In an automotive system, the infotainment application handles touch input, navigation, and media playback. Applications can be custom-built for unique products or adapted from open-source solutions, and they define what the system actually does for the end user.”</p>
<p><strong>Resources</strong></p>
<pre><code>•   Case studies on open-source automotive Linux (Automotive Grade Linux):</code></pre>
<p>https://www.automotivelinux.org/</p>
<pre><code>•   Yocto Project and embedded applications examples:</code></pre>
<p>https://www.yoctoproject.org/</p>
</section>
<section id="slide-root-filesystem-the-foundation-of-user-space" class="level2" data-number="3.19">
<h2 data-number="3.19" class="anchored" data-anchor-id="slide-root-filesystem-the-foundation-of-user-space"><span class="header-section-number">3.19</span> Slide: Root Filesystem: The Foundation of User Space</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.032.png" class="img-fluid figure-img"></p>
<figcaption>kernel</figcaption>
</figure>
</div>
<p><strong>Narrative</strong> “Once the kernel has completed its initial setup, it needs a structured environment where system programs and applications can run. This is the role of the root filesystem — it contains configuration files, system utilities, libraries, and applications that define the system’s user-space environment.</p>
<p>At startup, the kernel looks for a file called init, which becomes the first user-space process, kicking off system initialization and launching essential services.</p>
<p>Depending on the system, the root filesystem can reside entirely in RAM, especially in development setups where no persistent storage is needed. For production devices, it typically resides in persistent storage like flash memory. In some development workflows or specialized systems, the root filesystem may be loaded over the network, allowing rapid iteration and debugging without flashing the device repeatedly.”</p>
</section>
<section id="slide-root-file-system-illustrated" class="level2" data-number="3.20">
<h2 data-number="3.20" class="anchored" data-anchor-id="slide-root-file-system-illustrated"><span class="header-section-number">3.20</span> Slide: Root File System Illustrated</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lecture02/Lecture02_LinuxBasedEmbeddedSystemComponentStack/Lecture02_LinuxBasedEmbeddedSystemComponentStack.033.png" class="img-fluid figure-img"></p>
<figcaption>Root File System Illustrated</figcaption>
</figure>
</div>
<p><strong>Narrative</strong></p>
<p>*“Now that we’ve discussed what the root filesystem is and why it’s critical, let’s take a visual tour of its structure.</p>
<p>At the top level, we have the root directory, represented by a single slash /. Underneath it, the filesystem is organized into directories, each serving a specific role.</p>
<p>First, /bin contains essential user command binaries — these are the core utilities, like cp, ls, and bash, that are needed even if no other software is available.</p>
<p>Next, /etc holds configuration files for the system — think of network settings, hostnames, and startup scripts.</p>
<p>/sbin is where we find essential system binaries that administrators use for critical tasks like partitioning disks or configuring the network.</p>
<p>The /usr directory holds application support data, libraries, and binaries for user applications, while /var stores variable data files such as logs, cache files, and print spools that change as the system runs.</p>
<p>We also have special directories: • /dev contains device files that represent hardware. • /home is where user files reside. • /lib holds shared libraries and kernel modules. • /proc is a virtual filesystem that represents kernel and process information in real time. • /root is the root user’s home directory.</p>
<p>Finally, directories like /mnt and /opt are for mounting temporary filesystems and installing optional applications.</p>
<p>This structure is universal across Linux systems — including embedded Linux — and understanding it is essential for managing, troubleshooting, and customizing your devices. In future labs, we’ll navigate these directories to explore and modify real embedded Linux systems.”*</p>
</section>
<section id="review-for-module-02" class="level2" data-number="3.21">
<h2 data-number="3.21" class="anchored" data-anchor-id="review-for-module-02"><span class="header-section-number">3.21</span> Review for Module 02</h2>
<p><strong>Multiple Choice</strong></p>
<ol type="1">
<li>What is the primary role of a bootloader in an embedded Linux system?</li>
</ol>
<p>A) To run user applications</p>
<p>B) To initialize hardware and load the operating system</p>
<p>C) To manage file systems</p>
<p>D) To schedule kernel processes</p>
<hr>
<ol start="2" type="1">
<li>In an embedded SoC system, where is the operating system typically stored before being loaded into RAM?</li>
</ol>
<p>A) CPU registers</p>
<p>B) Boot flash memory</p>
<p>C) Mass storage flash</p>
<p>D) RAM</p>
<hr>
<ol start="3" type="1">
<li>Which component describes hardware to the Linux kernel in a flexible and updatable way?</li>
</ol>
<p>A) Kernel module</p>
<p>B) Device tree blob (DTB)</p>
<p>C) System call interface</p>
<p>D) Init process</p>
<hr>
<ol start="4" type="1">
<li>Which one of the following is NOT typically found in the root filesystem?</li>
</ol>
<p>A) Kernel binary</p>
<p>B) Configuration files in /etc</p>
<p>C) System utilities in /bin</p>
<p>D) The init process</p>
<hr>
<ol start="5" type="1">
<li>What advantage does a monolithic kernel provide?</li>
</ol>
<p>A) Complete separation of hardware and software</p>
<p>B) The ability to dynamically load user applications</p>
<p>C) Efficient execution by integrating all core functionalities</p>
<p>D) Guaranteed system stability in case of kernel bugs</p>
<hr>
<p><strong>Fill in the Blank</strong></p>
<ol start="6" type="1">
<li>The first user-space process launched by the Linux kernel during boot is called ________.</li>
</ol>
<hr>
<ol start="7" type="1">
<li>A ________ file is compiled from a Device Tree Source (DTS) file and passed to the kernel at boot.</li>
</ol>
<hr>
<ol start="8" type="1">
<li>The ________ filesystem stores essential binaries, configuration files, and user-space applications the kernel relies on after boot.</li>
</ol>
<hr>
<p><strong>Short Answer</strong></p>
<ol start="9" type="1">
<li>Briefly explain the role of the Program Counter (PC) at system power-up and how it relates to the reset vector.</li>
</ol>
<hr>
<ol start="10" type="1">
<li>List two key differences between a microcontroller-based embedded implementation and a system-on-chip (SoC)-based implementation.</li>
</ol>
<hr>
<ol start="11" type="1">
<li>Describe one advantage and one disadvantage of using a monolithic kernel in an embedded system.</li>
</ol>
<hr>
</section>
<section id="answer-key-for-module-02-review-questions" class="level2" data-number="3.22">
<h2 data-number="3.22" class="anchored" data-anchor-id="answer-key-for-module-02-review-questions"><span class="header-section-number">3.22</span> Answer Key for Module 02 Review Questions</h2>
<p><strong>Multiple Choice:</strong></p>
<p>1. B) To initialize hardware and load the operating system</p>
<p>2. C) Mass storage flash</p>
<p>3. B) Device tree blob (DTB)</p>
<p>4. A) Kernel binary</p>
<p>5. C) Efficient execution by integrating all core functionalities</p>
<p><strong>Fill in the Blank:</strong></p>
<p>6. init</p>
<p>7. Device tree blob (DTB)</p>
<p>8. root</p>
<p><strong>Short Answer:</strong></p>
<p>9. The Program Counter (PC) is set to the reset vector address at power-up. It tells the CPU where</p>
<p>to begin executing instructions, starting the bootloader process.</p>
<p>10. - MCU has integrated CPU, RAM, and flash memory on a single chip; SoC integrates CPU and</p>
<p>peripherals but often uses external RAM and storage.</p>
<p>- MCUs are used for simpler systems; SoCs support more complex, higher-performance</p>
<p>applications.</p>
<p>11. Advantage: High efficiency due to integrated functionality. Disadvantage: A bug in a kernel</p>
<p>component can crash the whole system.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./lecture01.html" class="pagination-link" aria-label="Intro. to Embedded Systems">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Intro. to Embedded Systems</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./module03.html" class="pagination-link" aria-label="Processes and OS Management">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Processes and OS Management</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>